import translationLayer
import transientSimulation

trigger_radian_rise_time = translationLayer.trigger_radian_rise_time
generation_resolution = translationLayer.generation_resolution
trigger_nominal_voltage = translationLayer.trigger_nominal_voltage
switching_period = translationLayer.switching_period

storage = transientSimulation.storage

trigger = []

def calc_rise_time_module(polarity): #calculate the current voltage of the rise time linearly, argument boolean polarity
    num_of_steps = (trigger_radian_rise_time / generation_resolution)
    delta_voltage_per_step = (trigger_nominal_voltage / num_of_steps)
    int_num_of_steps = 0
    while (int_num_of_steps < num_of_steps):
        if (polarity == 1):
            trigger.append(delta_voltage_per_step * int_num_of_steps)
        else:
            trigger.append(trigger_nominal_voltage - (delta_voltage_per_step * int_num_of_steps))
        int_num_of_steps = int_num_of_steps + 1

def calc_trigger_module():
    int_num_of_modules = 0
    while (int_num_of_modules < translationLayer.num_of_modules):
        calc_rise_time_module(1)
        int_high_counter = 0
        while (int_high_counter < (translationLayer.trigger_duty_cycle * len(storage))):
            trigger.append(trigger_nominal_voltage)
            int_high_counter = int_high_counter + 1
        calc_rise_time_module(0)
        int_low_counter = 0
        while (int_low_counter < ((1 - translationLayer.trigger_duty_cycle) * len(storage))):
            trigger.append(0)
            int_low_counter = int_low_counter + 1
        int_num_of_modules = int_num_of_modules + 1